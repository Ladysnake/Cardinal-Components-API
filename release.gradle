apply from: 'https://raw.githubusercontent.com/OnyxStudios/Gradle-Scripts/master/scripts/fabric/publish/changelog.gradle'
def MASTER_REPO = 'https://github.com/OnyxStudios/Cardinal-Components-API.git'

// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
// if it is present.
// If you remove this task, sources will not be generated.
task sourcesJar(type: Jar, dependsOn: classes) {
    archiveClassifier = "sources"
    from sourceSets.main.allSource
}

task checkGitStatus() {
    group = 'publishing'
    description = 'Checks that the git repository is in a state suitable for release'
    doLast {
        if (grgit == null) throw new RuntimeException('No git repository')
        if (!grgit.status().isClean()) {
            throw new RuntimeException("Git repository not ready for release (${grgit.status()})")
        }
        def masterRemote = (grgit.remote.list().find { it.url == MASTER_REPO } ?: grgit.remote.add {
            name = 'onyxstudios'
            url = MASTER_REPO
        }).name
        def currentTrackedBranch = grgit.branch.current().trackingBranch.getName().replaceAll(/.*\//, '')
        if (currentTrackedBranch != 'master' && !currentTrackedBranch.matches(/\d\.\d{2}/)) {
            throw new RuntimeException("Need to be on master or a dedicated version branch to release (currently on ${currentTrackedBranch})")
        }
        grgit.fetch(tagMode: 'all')
        grgit.fetch(remote: masterRemote, tagMode: 'all')
        grgit.pull(remote: masterRemote, branch: currentTrackedBranch, rebase: true)
        if (grgit.tag.list().any { it.name == project.version }) {
            throw new RuntimeException("A tag already exists for ${project.version}")
        }
        def status = grgit.branch.status(name: grgit.branch.current().getName())
        if (status.aheadCount != 0) {
            throw new RuntimeException('Some commits have not been pushed')
        }
        if (status.behindCount != 0) {
            throw new RuntimeException('Some commits have not been pulled')
        }
    }
}

githubRelease {
    token "${findProperty('github_releases_token')}"
}

task ladysnakeGithubRelease(type: project.tasks.githubRelease.getClass())

def configureGithubRelease(task, String repoOwner) {
    task.with {
        owner = repoOwner
        tagName = project.version
        targetCommitish = { grgit.branch.current().trackingBranch.name() }
        body = { project.getChangelogText() }

        FilenameFilter filter = { dir, filename -> filename.contains(project.version) && !filename.contains('-dev.jar') }
        releaseAssets = { jar.destinationDirectory.asFile.get().listFiles filter }
    }
    task.dependsOn(checkGitStatus)
}
configureGithubRelease(project.tasks.githubRelease, 'OnyxStudios')
configureGithubRelease(project.tasks.ladysnakeGithubRelease, 'Ladysnake')

bintray {
    user = project.findProperty('bintray_user')
    key = project.findProperty('bintray_api_key')
    publications = ['mavenJava']
    publish = true //[Default: false] Whether version should be auto published after an upload
    pkg {
        repo = 'mods'
        name = project.name
        userOrg = 'ladysnake'
        version {
            name = project.version
            vcsTag = project.version
            released  = new Date()
        }
    }
}

bintrayUpload.dependsOn(checkGitStatus)
bintrayUpload.dependsOn build

// configure the maven publication
publishing {
    publications {
        mavenJava(MavenPublication) {
            // Note: the main jar is already taken care of by the base builscript
            artifact(sourcesJar) {
                builtBy remapSourcesJar
            }
        }
    }

    // select the repositories you want to publish to
    repositories {
        mavenLocal()
    }
}

curseforge {
    apiKey = project.findProperty('curse_key') ?: ""

    if (project.hasProperty('curseforge_id')) {
        project {
            id = findProperty('curseforge_id')

            releaseType = project.release_type

            //usually automatically determined by the CurseGradle plugin, but won't work with fabric
            "${project.curseforge_versions}".split('; ').each {
                addGameVersion it
            }
            addGameVersion 'Fabric'

            mainArtifact(remapJar) {
                displayName = "${project.name}-${project.version}.jar"

                if (project.hasProperty('cf_requirements') || project.hasProperty('cf_optionals') || project.hasProperty('cf_embeddeds') || project.hasProperty('cf_tools') || project.hasProperty('cf_incompatibles') || project.hasProperty('cf_includes')) {
                    relations {
                        if (project.hasProperty('cf_requirements')) {
                            "${project.cf_requirements}".split('; ').each {
                                requiredDependency "${it}"
                            }
                        }
                        if (project.hasProperty('cf_optionals')) {
                            "${project.cf_optionals}".split('; ').each {
                                optionalDependency "${it}"
                            }
                        }
                        if (project.hasProperty('cf_embeddeds')) {
                            "${project.cf_embeddeds}".split('; ').each {
                                embeddedLibrary "${it}"
                            }
                        }
                        if (project.hasProperty('cf_tools')) {
                            "${project.cf_tools}".split('; ').each {
                                tool "${it}"
                            }
                        }
                        if (project.hasProperty('cf_incompatibles')) {
                            "${project.cf_incompatibles}".split('; ').each {
                                incompatible "${it}"
                            }
                        }
                        if (project.hasProperty('cf_includes')) {
                            "${project.cf_includes}".split('; ').each {
                                include "${it}"
                            }
                        }
                    }
                }
            }

            changelogType = 'markdown'
            changelog = project.getChangelogText()

            subprojects {
                addArtifact(remapJar) {
                    displayName = "${project.name}-${project.version}.jar"
                }
            }

            afterEvaluate {
                uploadTask.dependsOn remapSourcesJar
            }
        }
        options {
            forgeGradleIntegration = false
        }
    }
}

tasks.curseforge.dependsOn(checkGitStatus)

task release(dependsOn: [tasks.publish, tasks.githubRelease, tasks.ladysnakeGithubRelease, tasks.bintrayUpload, /*tasks.curseforge*/]) {
    group = 'publishing'
    description = 'Releases a new version to Maven, Github and Curseforge'
}
